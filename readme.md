### https://contest.yandex.ru/contest/47941/problems/
1. Написать функцию int FindKthLargestSmallest(node* root, int k). Если число k больше нуля, то функция должна вернуть k-ый максимальный элемент бинарного дерева поиска. Если k – отрицательное число, то найти k-ый минимальный элемент BST.
Например, пусть дано дерево
```
     8
    / \
  2    12
 / \
1  4
```
Тогда результаты вызовов функции будут
FubdJtgLargestSmallest(root, 1) == 12
FubdJtgLargestSmallest(root, -1) == 1
FubdJtgLargestSmallest(root, 2) == 8

2. Пусть дано бинарное дерево поиска. Введем понятия пола и потолка для некоторого элемента k. Если данный элемент присутствует в дереве поиска, то его пол и потолок совпадают между собой и равны значению этого элемента. Если элемент k отсутствует в дереве, то его пол – это ближайший узел снизу, потолок – ближайший сверху.

Например, пусть дано дерево
```
     8
    / \
  3    12
 / \
2  4
```
Потолок элемента 1 – это 2, пол – не существует.
Потолок и пол элемента 3 – это 3.
Для элемента 9 пол – 8, потолок – 12.

Требуется написать функцию void findFloorCeiling(node* root, int e, int& floor, int& ceiling), которая записывает в переменные floor и ceiling значения пола и потолка элемента e.

3. Написать функцию bool isOneSwapAwayFromBST(node* root), которая определяет, может ли данное дерево быть преобразовано в бинарное дерево поиска путем однократной перестановки любых двух его узлов.
Например, дерево
```
     8
    / \
  3    12
 / \
4  2
```
является таким.

4. Написать функцию node* DeleteOutsideRange(node* root, int begin, int end), которая удаляет из дерева все элементы, которые не попадают в диапазон от begin до end, т.е. в результирующем дереве должны быть только элементы от begin до end включительно.

5. Написать функцию int LeastCommonAncestor(node* root, node* elem1, node* elem2), которая возвращает значение наиболее близкого общего предка элементов elem1, elem2. 
Например, если дано дерево
```
     8
   /   \
  3     12
 / \      \
2   4     15
```
LeastCommonAncestor(root, root->left, root->right->right) == 8
LeastCommonAncestor(root, root->left->left, root->left->right) == 3

